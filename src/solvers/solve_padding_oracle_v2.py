#!/usr/bin/env python3
"""
Solucionador Mejorado para Padding Oracle Attack - chall.py
==========================================================

Versi√≥n mejorada con mejor manejo de comunicaci√≥n
"""

import socket
import time
import re

class PaddingOracleAttackerV2:
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.socket = None
        
    def connect_and_get_prophecy(self):
        """Conecta al servidor y obtiene la prophecy inicial"""
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.settimeout(10)  # Timeout de 10 segundos
            
            print(f"üîó Conectando a {self.host}:{self.port}...")
            self.socket.connect((self.host, self.port))
            
            # Leer toda la respuesta inicial
            initial_response = b""
            time.sleep(1)  # Dar tiempo al servidor
            
            while True:
                try:
                    chunk = self.socket.recv(4096)
                    if not chunk:
                        break
                    initial_response += chunk
                    
                    # Verificar si hemos recibido la prophecy completa
                    response_str = initial_response.decode('utf-8', errors='ignore')
                    if "Prophecy (HEX):" in response_str and "> " in response_str:
                        break
                        
                except socket.timeout:
                    break
            
            response_str = initial_response.decode('utf-8', errors='ignore')\n            print(f\"üì® Respuesta del servidor:\")\n            print(response_str)\n            \n            # Extraer la prophecy usando regex\n            prophecy_match = re.search(r'Prophecy \\(HEX\\): ([a-fA-F0-9]+)', response_str)\n            if prophecy_match:\n                hex_prophecy = prophecy_match.group(1)\n                prophecy_bytes = bytes.fromhex(hex_prophecy)\n                print(f\"üìú Prophecy extra√≠da: {hex_prophecy}\")\n                print(f\"üìè Longitud: {len(prophecy_bytes)} bytes\")\n                return prophecy_bytes\n            else:\n                print(\"‚ùå No se pudo extraer la prophecy\")\n                return None\n                \n        except Exception as e:\n            print(f\"‚ùå Error conectando: {e}\")\n            return None\n    \n    def query_oracle(self, ciphertext_hex):\n        \"\"\"Consulta el oracle con un ciphertext y obtiene respuesta\"\"\"\n        try:\n            # Enviar query\n            query = ciphertext_hex + \"\\n\"\n            self.socket.sendall(query.encode())\n            \n            # Leer respuesta\n            response = b\"\"\n            time.sleep(0.1)  # Peque√±a pausa\n            \n            while True:\n                try:\n                    chunk = self.socket.recv(1024)\n                    if not chunk:\n                        break\n                    response += chunk\n                    \n                    response_str = response.decode('utf-8', errors='ignore')\n                    \n                    # Verificar si tenemos respuesta completa\n                    if (\"well-formed\" in response_str or \"chaotic\" in response_str or \n                        \"Valid Padding\" in response_str or \"Invalid Padding\" in response_str):\n                        \n                        # Determinar el resultado\n                        if \"well-formed\" in response_str or \"Valid Padding\" in response_str:\n                            return True\n                        elif \"chaotic\" in response_str or \"Invalid Padding\" in response_str:\n                            return False\n                        \n                except socket.timeout:\n                    break\n            \n            print(f\"‚ö†Ô∏è  Respuesta inesperada: {response.decode('utf-8', errors='ignore')[:100]}...\")\n            return False\n            \n        except Exception as e:\n            print(f\"‚ùå Error en query_oracle: {e}\")\n            return False\n    \n    def decrypt_byte(self, known_bytes, target_position, c1, c2):\n        \"\"\"Descifra un byte espec√≠fico en la posici√≥n target_position\"\"\"\n        padding_length = 16 - target_position\n        \n        for guess in range(256):\n            # Crear el bloque modificado\n            modified_c1 = bytearray(c1)\n            \n            # Configurar bytes conocidos para producir el padding correcto\n            for i in range(target_position + 1, 16):\n                modified_c1[i] = c1[i] ^ known_bytes[i] ^ padding_length\n            \n            # Probar el guess actual\n            modified_c1[target_position] = guess\n            \n            # Crear ciphertext de prueba\n            test_ciphertext = bytes(modified_c1) + c2\n            test_hex = test_ciphertext.hex()\n            \n            # Consultar el oracle\n            if self.query_oracle(test_hex):\n                # Encontramos el byte correcto\n                original_byte = guess ^ c1[target_position] ^ padding_length\n                return original_byte\n        \n        return None\n    \n    def decrypt_block(self, c1, c2, block_num):\n        \"\"\"Descifra un bloque completo\"\"\"\n        print(f\"üîì Descifrando bloque {block_num}...\")\n        \n        decrypted_bytes = [0] * 16\n        \n        # Descifrar byte por byte (de derecha a izquierda)\n        for pos in range(15, -1, -1):\n            print(f\"  üìç Descifrando posici√≥n {pos} (byte {16-pos}/16)...\", end=\"\", flush=True)\n            \n            byte_value = self.decrypt_byte(decrypted_bytes, pos, c1, c2)\n            \n            if byte_value is not None:\n                decrypted_bytes[pos] = byte_value\n                print(f\" ‚úÖ {byte_value:02x} ('{chr(byte_value) if 32 <= byte_value <= 126 else '.'}')\")   \n            else:\n                print(f\" ‚ùå Fall√≥\")\n                return None\n        \n        return bytes(decrypted_bytes)\n    \n    def padding_oracle_attack(self, ciphertext):\n        \"\"\"Ejecuta el ataque completo\"\"\"\n        print(f\"\\nüéØ INICIANDO PADDING ORACLE ATTACK\")\n        print(f\"üìè Ciphertext: {len(ciphertext)} bytes\")\n        \n        # Dividir en bloques\n        blocks = []\n        for i in range(0, len(ciphertext), 16):\n            blocks.append(ciphertext[i:i+16])\n        \n        print(f\"üî¢ Bloques detectados: {len(blocks)}\")\n        \n        # El primer bloque es el IV\n        iv = blocks[0]\n        cipher_blocks = blocks[1:]\n        \n        print(f\"üìã IV: {iv.hex()}\")\n        for i, block in enumerate(cipher_blocks):\n            print(f\"üìã Bloque {i+1}: {block.hex()}\")\n        \n        # Descifrar cada bloque\n        decrypted_blocks = []\n        \n        for i, cipher_block in enumerate(cipher_blocks):\n            if i == 0:\n                prev_block = iv  # Primer bloque usa IV\n            else:\n                prev_block = cipher_blocks[i-1]  # Bloques siguientes usan el anterior\n            \n            decrypted_block = self.decrypt_block(prev_block, cipher_block, i+1)\n            \n            if decrypted_block is None:\n                print(f\"‚ùå Error descifrando bloque {i+1}\")\n                return None\n            \n            decrypted_blocks.append(decrypted_block)\n            print(f\"‚úÖ Bloque {i+1}: {decrypted_block.hex()} -> '{decrypted_block.decode('utf-8', errors='ignore')}'\")\n        \n        # Unir bloques y remover padding\n        full_plaintext = b''.join(decrypted_blocks)\n        \n        # Remover padding PKCS7\n        if full_plaintext:\n            padding_length = full_plaintext[-1]\n            if padding_length <= 16:\n                unpadded = full_plaintext[:-padding_length]\n                return unpadded\n        \n        return full_plaintext\n    \n    def close(self):\n        \"\"\"Cierra conexi√≥n\"\"\"\n        if self.socket:\n            self.socket.close()\n\ndef main():\n    print(\"üéØ PADDING ORACLE ATTACK - VERSI√ìN MEJORADA\")\n    print(\"=\" * 50)\n    print(\"üåê Target: 185.207.251.177:1600\")\n    print(\"üéÆ Challenge: chall.py\")\n    print()\n    \n    attacker = PaddingOracleAttackerV2(\"185.207.251.177\", 1600)\n    \n    try:\n        # Obtener prophecy\n        prophecy = attacker.connect_and_get_prophecy()\n        \n        if prophecy is None:\n            print(\"‚ùå No se pudo obtener la prophecy\")\n            return\n        \n        print(f\"\\nüìú Prophecy obtenida exitosamente!\")\n        print(f\"üìä Hex: {prophecy.hex()}\")\n        print(f\"üìè Tama√±o: {len(prophecy)} bytes\")\n        \n        # Ejecutar ataque\n        print(\"\\nüöÄ Ejecutando ataque...\")\n        flag = attacker.padding_oracle_attack(prophecy)\n        \n        if flag:\n            flag_str = flag.decode('utf-8', errors='ignore')\n            print(f\"\\nüéâ ¬°FLAG DESCIFRADA!\")\n            print(f\"üèÜ FLAG: {flag_str}\")\n            \n            # Guardar resultado\n            solved_file = \"challenges/solved/chall_padding_oracle_solution.txt\"\n            with open(solved_file, 'w', encoding='utf-8') as f:\n                f.write(f\"Challenge: chall.py (Padding Oracle Attack)\\n\")\n                f.write(f\"Host: 185.207.251.177:1600\\n\")\n                f.write(f\"Prophecy: {prophecy.hex()}\\n\")\n                f.write(f\"Flag: {flag_str}\\n\")\n            \n            print(f\"üíæ Soluci√≥n guardada en: {solved_file}\")\n        else:\n            print(\"‚ùå No se pudo descifrar la flag\")\n    \n    except KeyboardInterrupt:\n        print(\"\\n‚ö†Ô∏è  Ataque interrumpido\")\n    except Exception as e:\n        print(f\"‚ùå Error: {e}\")\n        import traceback\n        traceback.print_exc()\n    finally:\n        attacker.close()\n        print(\"üîå Conexi√≥n cerrada\")\n\nif __name__ == \"__main__\":\n    main()