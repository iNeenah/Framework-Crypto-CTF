#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Enhanced CTF Agent - Agente CTF Mejorado con Interpretaci√≥n Inteligente
=====================================================================
Versi√≥n mejorada del agente aut√≥nomo que integra el Knowledge Interpreter
para una mejor conexi√≥n entre los datos de entrenamiento y las soluciones.
"""

import os
import sys
import json
import socket
import subprocess
import tempfile
import re
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from datetime import datetime

# Agregar el directorio src al path para imports
sys.path.append(str(Path(__file__).parent / "src"))

try:
    from src.ml.knowledge_interpreter import KnowledgeInterpreter
    print("‚úÖ Knowledge Interpreter importado exitosamente")
except ImportError as e:
    print(f"‚ö†Ô∏è  Error importando Knowledge Interpreter: {e}")
    print("Usando modo b√°sico sin interpretaci√≥n avanzada")

class EnhancedCTFAgent:
    def __init__(self, api_key: str = None):
        self.base_dir = Path("c:/Users/Nenaah/Desktop/Programacion/GIT/CRYPTO")
        self.api_key = api_key or os.getenv('GEMINI_API_KEY')
        
        # Inicializar Knowledge Interpreter
        try:
            self.knowledge_interpreter = KnowledgeInterpreter(str(self.base_dir))
            print("üß† Knowledge Interpreter inicializado")
            self._show_knowledge_stats()
        except Exception as e:
            print(f"‚ö†Ô∏è  Error inicializando Knowledge Interpreter: {e}")
            self.knowledge_interpreter = None
        
        # Configurar IA si est√° disponible
        self.ai_model = None
        if self.api_key:
            try:
                import google.generativeai as genai
                genai.configure(api_key=self.api_key)
                self.ai_model = genai.GenerativeModel('gemini-1.5-pro')
                print("‚úÖ Gemini AI configurado")
            except Exception as e:
                print(f"‚ö†Ô∏è  Error configurando Gemini: {e}")
        
        # Estad√≠sticas de sesi√≥n
        self.session_stats = {
            'challenges_attempted': 0,
            'challenges_solved': 0,
            'flags_found': [],
            'techniques_used': [],
            'interpretations_successful': 0,
            'start_time': datetime.now()
        }
    
    def _show_knowledge_stats(self):
        """Muestra estad√≠sticas del conocimiento cargado"""
        if self.knowledge_interpreter:
            stats = self.knowledge_interpreter.get_knowledge_stats()
            print(f"üìä Knowledge Stats:")
            print(f"   ‚Ä¢ Challenges procesados: {stats['total_challenges_processed']}")
            print(f"   ‚Ä¢ Categor√≠as de patrones: {stats['pattern_categories']}")
            print(f"   ‚Ä¢ T√©cnicas analizadas: {stats['technique_count']}")
            print(f"   ‚Ä¢ Templates disponibles: {stats['solution_templates']}")
            
            if stats['top_techniques']:
                print(f"   ‚Ä¢ Top 3 t√©cnicas m√°s efectivas:")
                for i, tech in enumerate(stats['top_techniques'][:3]):
                    print(f"     {i+1}. {tech['technique']} (efectividad: {tech['effectiveness']:.2f})")
    
    def solve_challenge_enhanced(self, challenge_input: str, challenge_type: str = "auto") -> Dict:
        """
        Resuelve un desaf√≠o usando interpretaci√≥n inteligente de conocimiento
        """
        
        print(f"\nüöÄ === ENHANCED CTF SOLVER ===")
        print(f"Challenge Type: {challenge_type}")
        print(f"Input: {challenge_input[:100]}{'...' if len(challenge_input) > 100 else ''}")
        
        self.session_stats['challenges_attempted'] += 1
        
        result = {
            'success': False,
            'flag': None,
            'method': 'unknown',
            'confidence': 0.0,
            'execution_time': 0,
            'interpretation': None,
            'generated_code': None,
            'error': None
        }
        
        start_time = datetime.now()
        
        try:
            # Paso 1: Interpretaci√≥n inteligente del desaf√≠o
            print("\nüîç Paso 1: Interpretaci√≥n inteligente...")
            interpretation = self._interpret_challenge_smart(challenge_input)
            result['interpretation'] = interpretation
            
            if interpretation:
                self.session_stats['interpretations_successful'] += 1
                print(f"‚úÖ Interpretaci√≥n exitosa:")
                print(f"   ‚Ä¢ Tipo: {interpretation['challenge_type']}")
                print(f"   ‚Ä¢ Confianza: {interpretation['confidence']:.2f}")
                print(f"   ‚Ä¢ T√©cnicas recomendadas: {[t['technique'] for t in interpretation['recommended_techniques'][:3]]}")
            
            # Paso 2: Generaci√≥n de soluci√≥n basada en interpretaci√≥n
            print("\nüõ†Ô∏è  Paso 2: Generaci√≥n de soluci√≥n...")
            generated_code = self._generate_solution_smart(challenge_input, interpretation)
            result['generated_code'] = generated_code
            
            # Paso 3: Ejecuci√≥n de la soluci√≥n
            print("\n‚ö° Paso 3: Ejecutando soluci√≥n...")
            execution_result = self._execute_solution_safe(generated_code)
            
            if execution_result['success']:
                result['success'] = True
                result['flag'] = execution_result['output']
                result['method'] = 'enhanced_interpretation'
                result['confidence'] = interpretation['confidence'] if interpretation else 0.5
                
                self.session_stats['challenges_solved'] += 1
                self.session_stats['flags_found'].append(execution_result['output'])
                
                print(f"üéâ ¬°FLAG ENCONTRADA!")
                print(f"üèÅ FLAG: {execution_result['output']}")
            else:
                result['error'] = execution_result.get('error', 'Ejecuci√≥n fallida')
                print(f"‚ùå Error en ejecuci√≥n: {result['error']}")
                
                # Fallback: Intentar m√©todos simples
                print("\nüîÑ Intentando m√©todos de fallback...")
                fallback_result = self._try_fallback_methods(challenge_input)
                if fallback_result['success']:
                    result.update(fallback_result)
                    result['method'] = 'fallback'
        
        except Exception as e:
            result['error'] = str(e)
            print(f"‚ùå Error general: {e}")
        
        # Calcular tiempo de ejecuci√≥n
        result['execution_time'] = (datetime.now() - start_time).total_seconds()
        
        return result
    
    def _interpret_challenge_smart(self, challenge_input: str) -> Optional[Dict]:
        """Interpreta el desaf√≠o usando el Knowledge Interpreter"""
        
        if not self.knowledge_interpreter:
            print("‚ö†Ô∏è  Knowledge Interpreter no disponible")
            return None
        
        try:
            interpretation = self.knowledge_interpreter.interpret_challenge(challenge_input)
            return interpretation
        except Exception as e:
            print(f"‚ùå Error en interpretaci√≥n: {e}")
            return None
    
    def _generate_solution_smart(self, challenge_input: str, interpretation: Optional[Dict]) -> str:
        """Genera soluci√≥n usando interpretaci√≥n inteligente"""
        
        if not interpretation:
            return self._generate_basic_solution(challenge_input)
        
        try:
            # Usar Knowledge Interpreter para generar c√≥digo mejorado
            if self.knowledge_interpreter:
                enhanced_code = self.knowledge_interpreter.generate_enhanced_solution_code(
                    interpretation, challenge_input
                )
                return enhanced_code
            else:
                return self._generate_template_solution(interpretation, challenge_input)
        
        except Exception as e:
            print(f"‚ö†Ô∏è  Error generando soluci√≥n inteligente: {e}")
            return self._generate_basic_solution(challenge_input)
    
    def _generate_template_solution(self, interpretation: Dict, challenge_input: str) -> str:
        """Genera soluci√≥n basada en templates de interpretaci√≥n"""
        
        challenge_type = interpretation.get('challenge_type', 'unknown')
        
        if challenge_type == 'elliptic_curve':
            return self._generate_ec_solution(challenge_input, interpretation)
        elif challenge_type == 'rsa':
            return self._generate_rsa_solution(challenge_input, interpretation)
        elif challenge_type == 'xor':
            return self._generate_xor_solution(challenge_input, interpretation)
        else:
            return self._generate_basic_solution(challenge_input)
    
    def _generate_ec_solution(self, challenge_input: str, interpretation: Dict) -> str:
        """Genera soluci√≥n espec√≠fica para curvas el√≠pticas"""
        
        return f'''#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Soluci√≥n autom√°tica para Elliptic Curves
# Basada en interpretaci√≥n: {interpretation['challenge_type']}
# Confianza: {interpretation['confidence']:.2f}

def solve_elliptic_curve():
    import re
    import hashlib
    
    challenge_text = """{challenge_input}"""
    
    # Buscar flags directamente
    flag_pattern = r"crypto\\{{[^}}]+\\}}|flag\\{{[^}}]+\\}}"
    flags = re.findall(flag_pattern, challenge_text)
    if flags:
        return flags[0]
    
    try:
        # Configuraci√≥n Sage si est√° disponible
        from sage.all import *
        
        # Par√°metros comunes de CryptoHack
        p = 9739
        E = EllipticCurve(GF(p), [497, 1768])
        
        # Buscar puntos en el texto
        point_pattern = r"\\((\\d+),\\s*(\\d+)\\)"
        points = re.findall(point_pattern, challenge_text)
        
        if points:
            x, y = int(points[0][0]), int(points[0][1])
            P = E(x, y)
            
            # Operaciones comunes
            # Negaci√≥n: -P
            result = -P
            print(f"Negaci√≥n: {{result}}")
            
            # Multiplicaci√≥n escalar si hay n√∫mero
            numbers = re.findall(r'\\b(\\d{{4,}})\\b', challenge_text)
            if numbers:
                scalar = int(numbers[0])
                result = scalar * P
                print(f"Multiplicaci√≥n {{scalar}} * P = {{result}}")
            
            # Hash SHA1 de coordenada x
            x_coord = int(result[0])
            flag_hash = hashlib.sha1(str(x_coord).encode()).hexdigest()
            return f"crypto{{{flag_hash}}}"
    
    except ImportError:
        print("Sage no disponible, usando m√©todos b√°sicos")
    except Exception as e:
        print(f"Error en c√°lculo EC: {{e}}")
    
    return "Flag no encontrada"

if __name__ == "__main__":
    result = solve_elliptic_curve()
    print(f"FLAG: {{result}}")
'''
    
    def _generate_rsa_solution(self, challenge_input: str, interpretation: Dict) -> str:
        """Genera soluci√≥n espec√≠fica para RSA"""
        
        return f'''#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Soluci√≥n autom√°tica para RSA
# Basada en interpretaci√≥n: {interpretation['challenge_type']}

def solve_rsa():
    import re
    from math import gcd
    
    challenge_text = """{challenge_input}"""
    
    # Buscar flags directamente
    flag_pattern = r"crypto\\{{[^}}]+\\}}|flag\\{{[^}}]+\\}}"
    flags = re.findall(flag_pattern, challenge_text)
    if flags:
        return flags[0]
    
    try:
        # Buscar par√°metros RSA
        numbers = re.findall(r'\\b(\\d{{10,}})\\b', challenge_text)
        
        if len(numbers) >= 2:
            n = int(numbers[0])
            e = int(numbers[1])
            
            print(f"n = {{n}}")
            print(f"e = {{e}}")
            
            # Intentar factorizaci√≥n simple
            import gmpy2
            
            # Verificar si n es peque√±o
            if n < 10**20:
                for i in range(2, int(n**0.5) + 1):
                    if n % i == 0:
                        p, q = i, n // i
                        phi = (p - 1) * (q - 1)
                        d = gmpy2.invert(e, phi)
                        print(f"Factorizaci√≥n encontrada: p={{p}}, q={{q}}")
                        print(f"d = {{d}}")
                        break
        
    except Exception as e:
        print(f"Error en RSA: {{e}}")
    
    return "Flag no encontrada"

if __name__ == "__main__":
    result = solve_rsa()
    print(f"FLAG: {{result}}")
'''
    
    def _generate_xor_solution(self, challenge_input: str, interpretation: Dict) -> str:
        """Genera soluci√≥n espec√≠fica para XOR"""
        
        return f'''#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Soluci√≥n autom√°tica para XOR
# Basada en interpretaci√≥n: {interpretation['challenge_type']}

def solve_xor():
    import re
    
    challenge_text = """{challenge_input}"""
    
    # Buscar flags directamente
    flag_pattern = r"crypto\\{{[^}}]+\\}}|flag\\{{[^}}]+\\}}"
    flags = re.findall(flag_pattern, challenge_text)
    if flags:
        return flags[0]
    
    try:
        # Buscar datos hex
        hex_pattern = r'[0-9a-fA-F]{{20,}}'
        hex_data = re.findall(hex_pattern, challenge_text)
        
        for hex_str in hex_data:
            if len(hex_str) % 2 == 0:
                data = bytes.fromhex(hex_str)
                
                # XOR con keys comunes
                common_keys = [b'flag', b'key', b'crypto', b'A', b'\\x00']
                
                for key in common_keys:
                    try:
                        result = bytes(a ^ key[i % len(key)] for i, a in enumerate(data))
                        result_str = result.decode('utf-8', errors='ignore')
                        
                        if 'crypto{{' in result_str or 'flag{{' in result_str:
                            flag_match = re.search(flag_pattern, result_str)
                            if flag_match:
                                return flag_match.group(0)
                    except:
                        continue
    
    except Exception as e:
        print(f"Error en XOR: {{e}}")
    
    return "Flag no encontrada"

if __name__ == "__main__":
    result = solve_xor()
    print(f"FLAG: {{result}}")
'''
    
    def _generate_basic_solution(self, challenge_input: str) -> str:
        """Genera soluci√≥n b√°sica cuando no hay interpretaci√≥n espec√≠fica"""
        
        return f'''#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Soluci√≥n b√°sica autom√°tica

def solve_basic():
    import re
    import base64
    
    challenge_text = """{challenge_input}"""
    
    # 1. Buscar flags directamente
    flag_pattern = r"crypto\\{{[^}}]+\\}}|flag\\{{[^}}]+\\}}"
    flags = re.findall(flag_pattern, challenge_text)
    if flags:
        return flags[0]
    
    # 2. Decodificaci√≥n Base64
    try:
        b64_pattern = r'[A-Za-z0-9+/]{{20,}}=*'
        b64_matches = re.findall(b64_pattern, challenge_text)
        for b64_str in b64_matches:
            try:
                decoded = base64.b64decode(b64_str).decode('utf-8')
                flag_in_decoded = re.findall(flag_pattern, decoded)
                if flag_in_decoded:
                    return flag_in_decoded[0]
            except:
                continue
    except:
        pass
    
    return "Flag no encontrada"

if __name__ == "__main__":
    result = solve_basic()
    print(f"FLAG: {{result}}")
'''
    
    def _execute_solution_safe(self, code: str) -> Dict:
        """Ejecuta la soluci√≥n de manera segura"""
        
        try:
            # Crear archivo temporal
            with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
                f.write(code)
                temp_file = f.name
            
            # Ejecutar con timeout
            result = subprocess.run(
                [sys.executable, temp_file],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            # Limpiar archivo temporal
            os.unlink(temp_file)
            
            if result.returncode == 0:
                output = result.stdout.strip()
                # Extraer flag del output
                flag_match = re.search(r'FLAG: (.+)', output)
                if flag_match:
                    return {'success': True, 'output': flag_match.group(1)}
                else:
                    return {'success': True, 'output': output}
            else:
                return {'success': False, 'error': result.stderr}
        
        except subprocess.TimeoutExpired:
            return {'success': False, 'error': 'Timeout en ejecuci√≥n'}
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def _try_fallback_methods(self, challenge_input: str) -> Dict:
        """M√©todos de fallback cuando falla la interpretaci√≥n principal"""
        
        print("üîÑ Intentando m√©todos de fallback...")
        
        # M√©todo 1: B√∫squeda directa de flags
        flag_pattern = r'crypto\{[^}]+\}|flag\{[^}]+\}'
        flags = re.findall(flag_pattern, challenge_input, re.IGNORECASE)
        if flags:
            return {'success': True, 'flag': flags[0], 'method': 'direct_search'}
        
        # M√©todo 2: Base64 decode
        try:
            import base64
            b64_pattern = r'[A-Za-z0-9+/]{20,}=*'
            b64_matches = re.findall(b64_pattern, challenge_input)
            for b64_str in b64_matches:
                try:
                    decoded = base64.b64decode(b64_str).decode('utf-8')
                    flag_in_decoded = re.findall(flag_pattern, decoded, re.IGNORECASE)
                    if flag_in_decoded:
                        return {'success': True, 'flag': flag_in_decoded[0], 'method': 'base64_decode'}
                except:
                    continue
        except:
            pass
        
        return {'success': False, 'error': 'Todos los m√©todos de fallback fallaron'}
    
    def get_session_summary(self) -> Dict:
        """Retorna resumen de la sesi√≥n actual"""
        
        duration = (datetime.now() - self.session_stats['start_time']).total_seconds()
        
        return {
            'session_duration_seconds': duration,
            'challenges_attempted': self.session_stats['challenges_attempted'],
            'challenges_solved': self.session_stats['challenges_solved'],
            'success_rate': self.session_stats['challenges_solved'] / max(self.session_stats['challenges_attempted'], 1),
            'interpretations_successful': self.session_stats['interpretations_successful'],
            'flags_found': self.session_stats['flags_found'],
            'techniques_used': list(set(self.session_stats['techniques_used']))
        }

# Funci√≥n de conveniencia para uso directo
def solve_ctf_challenge(challenge_input: str, api_key: str = None) -> Dict:
    """
    Funci√≥n conveniente para resolver un desaf√≠o CTF
    """
    agent = EnhancedCTFAgent(api_key=api_key)
    return agent.solve_challenge_enhanced(challenge_input)

if __name__ == "__main__":
    # Ejemplo de uso
    test_challenge = """
    Challenge: CryptoHack Base64
    
    Can you decode this?
    Y3J5cHRve2Jhc2U2NF9pc19lYXN5fQ==
    """
    
    print("üß™ Probando Enhanced CTF Agent...")
    agent = EnhancedCTFAgent()
    result = agent.solve_challenge_enhanced(test_challenge)
    
    print(f"\nüìä Resultado:")
    print(f"‚úÖ √âxito: {result['success']}")
    if result['success']:
        print(f"üèÅ Flag: {result['flag']}")
        print(f"üõ†Ô∏è  M√©todo: {result['method']}")
        print(f"üìà Confianza: {result['confidence']:.2f}")
    else:
        print(f"‚ùå Error: {result['error']}")
    
    print(f"\n‚è±Ô∏è  Tiempo de ejecuci√≥n: {result['execution_time']:.2f}s")
    
    # Mostrar resumen de sesi√≥n
    summary = agent.get_session_summary()
    print(f"\nüìà Resumen de sesi√≥n:")
    print(f"   ‚Ä¢ Challenges intentados: {summary['challenges_attempted']}")
    print(f"   ‚Ä¢ Challenges resueltos: {summary['challenges_solved']}")
    print(f"   ‚Ä¢ Tasa de √©xito: {summary['success_rate']:.2f}")